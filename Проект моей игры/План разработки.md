План разработки игры в стиле RogueLike. Для реализации задуманного проекта надо сделать следующие задачи почти в свободном порядке. [[Архитектура проекта]]

### Главное меню
1. Старт игры [[Main Menu]] - Создание персонажа [[Выбор персонажа]] с возможностью выбирать из нескольких классов и визуальный редактор персонажа. Так же происходит запись и сохранение персонажа через [[Система сохранений]]. Создать скрипты отвечающие за интернет соединение с сервером [[Игровой сервер]].  Реализовать [[Синглтон]] классы начиная с Boostap-класса [[GameManager]]
2. Настройки звука [[Работа с аудио]], нужны звуки для темы меню, спокойный игры и звук преследования, звук смерти. 
3. Определить основной игровой механизм [[Основной игровой механизм]]
4. Создать дизайны и анимации [[Дизайн]]
5. Создать [[План сцены для 2D RogueLike игры]]
6. Игровая логика 
7. Карта и пространство игры 
8. Персонаж
9. Интерфейс персонажа 



#### 21.11.24
Добавил меню загрузок сохранений 
Теперь отображаются имена сохраненных пользователей и онм хранятся в формате json в папке системы, надо настроить визуальную составляющую и файлы - данные которые сохраняются, что бы это было не только имя, но и все состояние игры 

Изменения были в Скриптах [[SaveLoadManager]] 
Добавил скрипт [[SaveLoadMenu]] с реализацией GUI интерфейса 
Скрипт [[GameData]] является тестовым для проверки, но в будущем можно сделать отдельным игровым скриптом для сохранения данных 
В методе *Create()* в [[Main Menu]] добавил строку для сохранения в формате *.json*

Цель:
1. Визуальное отображение данных сохранения
2. Переход при выборе сохранения к следующей сцене
3.  Возможность удаления сохранения
4. Изменение загрузки данных пользователя при заходе в игру в методе [[GameManager]]
5. Настройка отдельного скрипта использующегося как сбор данных для сохранения 
6. Сделать запись даты сохранения и сортировать их по дате


#### 22.11.24
Реализую метод [[Delete Saved File]]

Глобально переделал обращение к классу User - постарался сделать во всех классах обращение через Instance 
Добавил методы отвечающие за выбор и удаление сохраненых файлов в формате .json
Теперь при загрузке через Меню - выбирает нужное имя, НО было обнаружено и без того большое количество багов и не доработок, выписал их в заметки

Правки:
1. Изменить отображение картинок звука с двух объектов на массив спрайтов
2. Неправильная подгрузка элементов при перезапуске сцены - выдает ошибки с взаимодействии с объектами управления, отображения и я их не понимаю
3. Не меняет имя после изменения в меню загрузки
4. Проще говоря - не правильно работает вся подгрузочная часть когда игра уже работает

Из целей остались следующие
Цель:
1. Визуальное отображение данных сохранения
2. Изменение загрузки данных пользователя при заходе в игру в методе [[GameManager]] ии полная его настройка с подключением и других классов менеджеров
3. Настройка отдельного скрипта использующегося как сбор данных для сохранения 
4. Сделать запись даты сохранения и сортировать их по дате

#### 23.11.24
Реализация скрипта Boostap-класса [[GameManager]] - необходимо написать скрипт который отвечает за работу *GameManager*, так же проверить почему класс *User* не загружается в GameManager и отображается как Пустота, хотя сам объект присутствует
*При всем при этом, если обращатся на прямую к классу User.Instance - то он откликается, и признает его имя после загрузки.
Пришлось изменить в классе SaveManager метод Start() на Awake() и добавить туда User.Instance=LoadLastGame() и заменить все обращения к User через класс GameManager на обращение к User.Instance во всех других частях кода и скриптах
В данной ситуации код работал верно* 

Добавил скрипт [[GameManager]]

Цель:
1. Визуальное отображение данных сохранения +
2. Изменение методов загрузки и сохранения в меню паузы [[PauseMenu]] +
3. Изменение загрузки данных пользователя при заходе в игру в методе [[GameManager]] и полная его настройка с подключением и других классов менеджеров через метод Boostap-класса +
4. Проверка подключения Менеджеров к GameManager +
5. Настройка обновления информации об игроке, при загрузке другого игрока, сделать скрипт\метод который будет отвечать за обновление всех выведенных данных пользователя при запуске и изменении их при загрузке нового [[SaveLoadRefresh()]] 
6. Добавить в настройки - скрипт\метод, который будет отвечать за выход пользователя, что бы обнулить User/Instance и не был введен пользователь
7. Настройка отдельного скрипта использующегося как сбор данных для сохранения [[GameData]]
8. Сделать запись даты сохранения и сортировать их по дате


#### 25.11.24
[[Разработка 25.11]] - составили правки, надо будет выполнить 


#### 27.11.24
Визуальное отображение данных сохранения в меню загрузки - решил оставить просто текстом (но лучше сделать возможность выбора и подсветки)
Сделал отображение подсветкой текста при выборе [[Подсветка текста при выборе для визуального отображения]]
Настроил часть менеджера [[GameManager]], появилась возможность поиска необходимых элементов сцены и добавил *SceneManagerHelper* для использования его статического метода проверки статуса сцены.
Добавим функционал системы сохранения тайловых карт, для возможности загружать уровни без смены сцен [[Система сохранения и загрузки тайловых карт]] -> ДОМОЙ ПРИШЕЛ-ДОДЕЛАЙ!!!

Добавил скрипты отвечающие за функционал загрузки и сохранение статуса карты. Сохранение данных игрока и противников на карта при вызове метода. 
Данным алгоритмом можно реализовать поиск и сохранение позиций противников и запись их в основые сохранения в секторе карты
Надо доделывать и реализовать в самой игре, НЕОБХОДИМО создать и добавить функционал сохранения самой карты и ее загрузки при переходе между элементами
**
Добавил функционал выбор персонажа в момент создания персонажа [[Создание интерфейса для выбора героя]]
**


Цель:
1. Настроить смену данных и их отображение при загрузке (кнопка LOAD) ничего не загружает в сцену игры
2. Настроить сброс сцены игры при смене пользователя 
3. Продолжить настройку *GameManager*
4. Настройка обновления информации об игроке, при загрузке другого игрока, сделать скрипт\метод который будет отвечать за обновление всех выведенных данных пользователя при запуске и изменении их при загрузке нового [[SaveLoadRefresh()]] 
5. . Добавить в настройки - скрипт\метод, который будет отвечать за выход пользователя, что бы обнулить User/Instance и не был введен пользователь
6. Настройка отдельного скрипта использующегося как сбор данных для сохранения [[GameData]] и добавить функцию записи времени
7. [[Система сохранения и загрузки тайловых карт]] ДОДЕЛАТЬ
8.  Надо доделывать и реализовать в самой игре, НЕОБХОДИМО создать и добавить функционал сохранения самой карты и ее загрузки при переходе между элементами
9. Создать хранилище для самих карт возможно в *.JSON*
10. Обновить заметку с [[План Заметок]]
11. Написать [[Экономическая модель игры]] 

#### 28.11.24
Создал префабы объектов на сцене, что бы были элементы не тайлами ,а спрайтами с возможностью столкновения и обхода их
Добавил скрипт на сундук и дверь ,который будет ответственен за открытие и закрытие и смену спрайтов (пока туда ничего не написал, сделал только массив спратов)
Сделал основную карту - префабом MAP_1 и добавил префаб карту TAVERNA
Сделал освещение не от верхнего источника света, а от персонажа 
[[Освещение и переключение освещения]]
Накачал много новых спрайт моделек - подготовить из них объекты и расфасовать по папкам необходимое для проекта 

Создание редактора карт [[Редактор карты]]

Цель:
1. Настроить смену данных и их отображение при загрузке (кнопка LOAD) ничего не загружает в сцену игры
2. СДЕЛАТЬ ИСТОЧНИКИ СВЕТА НА СЦЕНЕ +
3. Настроить сброс сцены игры при смене пользователя 
4. Продолжить настройку *GameManager*
5. Настройка обновления информации об игроке, при загрузке другого игрока, сделать скрипт\метод который будет отвечать за обновление всех выведенных данных пользователя при запуске и изменении их при загрузке нового [[SaveLoadRefresh()]] 
6. . Добавить в настройки - скрипт\метод, который будет отвечать за выход пользователя, что бы обнулить User/Instance и не был введен пользователь
7. Настройка отдельного скрипта использующегося как сбор данных для сохранения [[GameData]] и добавить функцию записи времени
8. [[Система сохранения и загрузки тайловых карт]] ДОДЕЛАТЬ
9.  Надо доделывать и реализовать в самой игре, НЕОБХОДИМО создать и добавить функционал сохранения самой карты и ее загрузки при переходе между элементами
10. Создать хранилище для самих карт возможно в *.JSON*
11. Обновить заметку с [[План Заметок]]
12. Написать [[Экономическая модель игры]] 

#### 29.11.24
Добавил источники света на сцене в виде Обелисков и свет от самого персонажа 
Добавил свет от сундуков 
Закинул в проект новые спрайты.

Цель:
1. Настроить смену данных и их отображение при загрузке (кнопка LOAD) ничего не загружает в сцену игры
<font color="#ffff00">2. СДЕЛАТЬ ИНВЕНТАРЬ ПЕРСОНАЖА!!!</font>
<font color="#ffff00">3. ИЗМЕНИТЬ МОДЕЛЬКУ ПЕРСОНАЖА И СКЕЛЕТА (анимации, атака магией от персонажа)</font>
4. Настроить сброс сцены игры при смене пользователя 
5. Продолжить настройку *GameManager*
6. Настройка обновления информации об игроке, при загрузке другого игрока, сделать скрипт\метод который будет отвечать за обновление всех выведенных данных пользователя при запуске и изменении их при загрузке нового [[SaveLoadRefresh()]] 
7.  Добавить в настройки - скрипт\метод, который будет отвечать за выход пользователя, что бы обнулить User/Instance и не был введен пользователь
8. Настройка отдельного скрипта использующегося как сбор данных для сохранения [[GameData]] и добавить функцию записи времени
9. [[Система сохранения и загрузки тайловых карт]] ДОДЕЛАТЬ
10.  Надо доделывать и реализовать в самой игре, НЕОБХОДИМО создать и добавить функционал сохранения самой карты и ее загрузки при переходе между элементами
11. Создать хранилище для самих карт возможно в *.JSON*
12. Обновить заметку с [[План Заметок]]
13. Написать [[Экономическая модель игры]] 

#### 1.12.24
Изменил скрипт *PauseMenu*, сделал окно меню паузы префабом и теперь оно загружается по просьбе пользователя и удаляется, <font color="#ffff00">НО ПОЧЕМУ ТО НЕ РАБОТАЕТ МЕТОД *RESUME()*!!!</font>++
Добавил заметку [[Динамическая загрузка и удаление UI окон]]
Сделал методы общими для всех GUI-элементов в сцене игры и все заработало. <font color="#92d050">Теперь можно будет вызывать и другие окна префабы из GUIManager</font>
*Таким же методом надо будет настроить MainManu окна до 9.12.24*
Добавил в проект игры три новых скрипта
*Item, Inventory, InventoryUI* - буду их заполнять
Класс *Item* - ответственен за свойства предметов
Скрипт *Inventory* - логика инвентаря
Скрипт *InventoryUI* - отображение инвентаря
[[Инвентарь]] - добавил код, осталось его использовать в среде Unity

*Скрипт сохранения состояния инвентаря у персонажа*

Цель:
1. Настроить смену данных и их отображение при загрузке (кнопка LOAD) ничего не загружает в сцену игры
2.  Настроить сброс сцены игры при смене пользователя 
3. Продолжить настройку *GameManager*
4. Настройка обновления информации об игроке, при загрузке другого игрока, сделать скрипт\метод который будет отвечать за обновление всех выведенных данных пользователя при запуске и изменении их при загрузке нового [[SaveLoadRefresh()]] 
5.  Добавить в настройки - скрипт\метод, который будет отвечать за выход пользователя, что бы обнулить User/Instance и не был введен пользователь
6. Настройка отдельного скрипта использующегося как сбор данных для сохранения [[GameData]] и добавить функцию записи времени
7. [[Система сохранения и загрузки тайловых карт]] ДОДЕЛАТЬ 
8.  Надо доделывать и реализовать в самой игре, НЕОБХОДИМО создать и добавить функционал сохранения самой карты и ее загрузки при переходе между элементами 
9. Создать хранилище для самих карт возможно в *.JSON* 
10. Обновить заметку с [[План Заметок]]
11. Написать [[Экономическая модель игры]] 

#### 2.12.24
Продолжаем реализовать Инвентарь - пока как заглушку с полями для элементов 
Сделал InventoryUI - отображени и закрытие инвенторя происходит в скрипте GUI_Manager/
Открывается на 6х6 ячеек, окно InventoryUI - существует как префаб и загружается отдельным объектом из файлов игры, а не прямо из сцены
Начал писать методы для итемов - для хранения их в инвентаре
[[Items]]
Добавил несколько новых спрайтов для предметов и возможность реализации подбора предмета
Новый скрипт прикрепляется ко всем префабам предметов, которые герой должен будет способен подбирать 
Добавил метод обновления инвентаря в InventoryUI и немного переработал класс Item 
Переход между картами [[Переход между картами]]
Сделал возможность загрузки карт из префабов, а не объектов игры. 
Теперь персонаж может телепортироваться между карт, но пока только на одну и ту же точку в карте.
Каждая дверь будет способна переходить к разным картам, но указываем их по индексу (можно запутаться, возможно проще реализовать подключение замих префабов к каждой двери отдельно, без одного сплошного MapManager) На данный момент переход между комнат возможен, но надо его дорабатывать 

<font color="#ffff00">Сделать корутину, что предмет поднимался только в одном экземплчре</font>
<font color="#ffff00">Настроить появление противников на карте при загрузке</font>

Цели теперь пишу прямо на ГИТЕ в ISSUES

#### 3.12.24
Сделал кнопки и методы для открытия таких пунктов игрового меню как 
*Характеристики, Настройки, Награды* по типу открытия инвентаря 
Написал новый Task на ГитХабе, что должно быть в каждом из окон


#### 4.12.24
Сделал метод загрузки и отображения характеристик персонажа. 
Скрипт PlayerStats отвечает за хранение данных о характеристиках персонажа и первом создании.
В скрипте MainMenu - добавил метод создания характеристик, что бы после создания персонажа ему были присвоены все необходимые параметры (пока без возможности настройки характеристик, только по умолчанию) 
В метод GameData - добавил поле для хранения данных о классе playerStats
В класс Player - добавил ссылку на статистику персонажа и метод для его установки от User.Instance
В скрпте User - добавил поле для хранения информации о playerStats
И добавил класс - реализующий отображение характеристик - PlayerCharacteristicsWindow
[[Характеристики персонажа]]
Сделал наследуемый класс - [[OptionsVolumeController]] - для создания опции меню - настройки звука внутри игрового процесса в HUD Опции
Добавил методы для обработки звуков от самого персонажа, а не только игрового окружения
Сделаем меню с [[Меню Достижений]]
Написал методы для отображения ачивок и сохранения их
Скрипт AchievementsMenuUI - отвечает за отображение достижений  и наград
Скрипт PlayerAchievements - отвечает за хранение самих наград и достижений
В скриптах Player, User и MainMenu - добавил методы и поля, для отображения и хранения данных об ачивках нашего игрока

Сделаем возможность, что бы из сундука выпадали предметы (пока определенные)
[[Выпадение предметов из сундука]]
Добавил событие для кнопки "E" - событие открытия
В данном случаем буду использовать для открытия сундуков
Добавил скрипт TreasureChest - отвечающий за хранение в сундуке и логику выпадание предмета
Начал работу над скриптом отвечающим за анимацию открытия сундука

[[Наследование]] - наследовать от класса *Enemy* и сделать класс *Window*


Цель:

Согласовать характеристики с другими методами персонажа, что бы его урон, мана, макс здоровье и все прочее устанавливалось от метода PlayerStats

Необходимо настроить согласованность в Меню и игре, и отображение слайдеров сразу на уровне громкости где они находятся.
Так же необходимо перенести кнопку Выключения звука в соответствующее меню

#### 5.12.24
Дописал скрипт отвечающий за работу анимации открытия и закрытия сундука, и за синхронное отображение тени при изменении состояния сундука.
Добавил новых спрайтов сундуков
Начинаем разработку [[Сундук хранилище]]
Сделал модельку сундука - цель написать его логику и анимацию 

#### 6.12.24
Добавил скрипты отвечающие за логи управления и отображения интерфейса инвентаря-сундука хранилища 
В скрипте InventoryUI - сделал методы protected и virtual - для переопределения их в StorageInventoryUI - дочерний класс
StorageChest- логика сундука
StorageInventory- наследуемый класс Инвентарь, для изменения логики инвентаря под логику инвентаря-хранилища
StorageInventoryUI- отображение инвентаря

Debuging: MapManager и User - необходимо почистить переменный касательно инвентаря игрока - какие и как используются и что откуда тянется что бы код был более читаем и чистым
необходимо продолжить делать чистку дальше, пока проект не разросся еще больше

Добавил к сундуку-хранилищу скрипты от сундука с выпадением предметов (отображение надписи при приближении и запуск логики открытия на кнопку - надо доделать далее)

Для отображения окна сундука хранилища - можно реализовать способ отображения отдельного HUD - окна, которое будет отвечать и отображать информацию о хранящихся объектах внутри сундука и отображаться на Canvas от GUI_Manager. В данном случае не потребуется создавать объект от самого сундука, а можно от сундука обратится к GUI_Manager и открыть окно с содержимым сундука

Сделал префаб инвентаря сундука - теперь необходимо их состыковать между собой, настроил присоединение объектов друг к другу (была ошибка от монобихавиор) 
И обновил способы доступа от Map_Manager до инвентаря игрока - через инстанс, а не файнд обджект


Цель - необходимо настроить отображение инвентаря Сундука-хранилища, что бы он создавался как префаб и открывался вместе с инвентарем игрока для совершения обмена

#### 8.12.24
Разберемся с [[Методы Find()]]

Сделал дебаг ,когда удалялся префаб ячейки (оказывается подключл его не из фаловЮа с инспектора)
Убрал в скриптах StorageInventoryUI - подписку на событие (очеь много элементов в конечном итоге к нему обращалось и вызывало ошибки)
Поправил скрипт обновления инвентаря в GUIManager -так как наш нвентарь создается с самого начала при вызове, нам нет смысла его столько раз обновлять

Сегодня добавил скрипт анимации и сами аниматоры для открытия и закрытия сундука
Пока только откликается на триггер открытие - и автоматически закрывается после срабатывания события

Надо сделать так, что бы он закрывался после закрытия меню с сундуком
Сделать

- [ ] Взаимное открытие окна с окном инвентаря персонажа
- [ ] Сделать в одном открытие два инвентаря (что бы не было ошибок) 
- [ ] Сделать возможность перетаскивать предметы из инвентаря в инвентарь
- [ ] Сделать возможность ссылаться и хранить информацию о сундуке и вещах в нем, что бы эту информацию можно было сохранять

#### 11.12.24
Делаем правки по курсу от преподавателя
Удалил класс User - и заменил его промежуточным классом PlayerData - который ответственен за хранение информации для сохранения о нашем игроке и его состоянии (таких как ачивки, характеристики, инвентарь, имя)

<u>Новый трабл - надо настроить скрипт так, что бы инвентарь персонажа загружался вместе с PlayerData, но почему то вызываются ошибки </u>

Обновил класс [[GameData]] - на данный момент нигде не используется, н ов будущем потребуется для сохранения состояния игрового мира

Напишем класс [[Window]] и добавим метод для его отображения в [[GUI Пользователя]]
Теперь в нашем GUIManager есть три метода отображения окон
1. Отвечает за HUD интерфейс
2. Отвечает за информационные окна
3. Отвечает за приоритетные окна 

Добавил новые методы в MenuManager и сделал его элементы префабами - надо их настроить

#### 12.12.24
Попытки настроить отображение окон в Главном меню по принципу загрузки игровых окон оказалось безуспешным, поскольку почему то скрипт обращался к префабу MenuManager - который находился в файлах Assets , а не в окне Hiearchy. На данный момент оказался от этой затеи. Главное меню не перегружено и нет ничего страшного, что сейчас оно работает как полностью загруженный интерфейс объектов. Позже постараюсь разобраться с данной проблемой.
Почистил класс PauseMenu - были лишние переменные и методы (Надо будет настроить данный класс для корректного автосохранения) 
Подключил инвентарь Игрока к Инвентарю в данных GameManager.Instance.playerData.playerInventory - теперь они согласовываются в методе Update в классе Player. 

Продолжаю настройку [[Окна с очередью]]
Настроил их - завтра цель [[Приоритетные окна]]

#### 13.12.24
Сделал приорететные окна
Поменял расположение префабов в папках проекта

Сделал отображение по очереди Настроил отображение первой сцены в игре Распределил окна по их значимости Сделал возможность вызова окон с ошибками Добавил в АудиоМенеджер - ссылку на АудиоИгрока
 Написал [[ResourcesLoadManager]] что бы он был ответственен за загрузку префаб элементов в фалов игры 

На данный момент вижу два способа реализации
- [x] Загрузка непосредственно по указанию имени, но тогда не понятно как реализовать массив
- [x] Заполнить массив по загрузке напрямую по имени 

переопределил использование метода загрузки, на загрузку через фалы прпоекта с resources 
И немного поправил инвентарь (вылезаза ошибка о его отсутствии) 

Добавил скрипт отвечающий за установку сложности сложность [[DifficultyManager]]

Теперь предмет поднимается 1 раз и сразу отображается в инвентаре персонажа

#### 15.12.24
Как один из способов инициализации всех наших скриптов без использования Start и Awake - может быть инициализация и присвоение нужным им значениям через определенные методы и вызывать их в скриптах , откуда мы хотим брать эти данные с использование FindObjectOfType - на данный момент считаю это достаточно выгодным способом реализации, что бы не путаться в Start и Awake

#### 19.12.24
Нашел причину почему лагал файрбол - не хватало ригидбоди 
Теперь наш снаряд уничтожается и срабатывает, не только при атаке противника, но и при столкновении с обычными объектами 
Так же наш шар, теперь поворачивается в сторону выстрела 
Напишем скрипт для отображения значении манны, хп  и опыта перса [[PlayerStatsUIManager]]
Написал и настроил общий скрипт, который отвечает за манну, здоровье и опыт - дальше надо сделать логику для опыта и уровней персонажа, восстановление здоровья и манны со временем 

#### 20.12.24
Сделал загрузку пользовательских окон - с использованием статических методов прямо из скриптов отвечающих за данные окна.
Сделал загрузку информационных окон -  в массив и использованием пути к папке resources
Надо добавить паттерн [[Наблюдатель]]

#### 21.12.24
Внедряю паттерн [[Наблюдатель]], завтра опишу что добавил и зафиксирую сделанную работу 
Добавил интерфейс и класс Subject
В принципе механизм наблюдателя, был уже добавлен в проект - но он был децентрализован, а с исполнением через паттерн можно будет собрать все необходимое в одном месте и управлять им

#### 23.12.24
Делаю отчет для завтрашней презентации по проекту
[[Отчет по проекту 24.12.24]]

#### 2.01.24
Настроил сцену, конкретнее поправил логику файрьболов, теперь они помечены как Player и меч тоже имеет Tag Player
Добавил метоод для загрузки префабов менеджеров на сцену, так как нам необходимо переключить все запуски в методах Start и Awake на определенный порядок действий

#### 3.01.24
Как показало изучение паттернов, Obsever - мне особо то и не нужен, сам EventHandler - это синтаксический сахар от C# который дает минимальный функционал данного паттерна.
Удалять написанное пока что не буду ,вдруг еще пригодится, поскольку с помощью Наблюдателя можно передавать более сложные структуры. 
Изучаю паттерны [[DI и ServiceLocator]] и [[DI]] [[Сервис локатор]]
Написал скрипт для ServiceLocator и добавил его в Player, для проверки работоспособности на GameInputManager

#### 4.01.24
Добавил интерфейсы AudioManager и SaveManager для написания скрипта и создания зависимостей через DI и так же для запуска через [[InitializationManager]]
Но для правильного функционирования, для начала необходимо определить все необходимые интерфейсы, чем я и займусь [[Определяем интерфейсы]]
И перепишем для примера скрипт [[AudioManager]]

Продолжаю переписывать код игры, что бы избавится от большого количества сингл тонов и перейти на ServiceLocator и DI. 
Сейчас работаю над InitializationManager, который ответственнен за запуск скриптов нашей игры в необходимом нам порядке и что бы он производил все нужные инициализации файлов

#### 5.01.24
Добавил интерфейсы и переписал Instance в VolumeControler и AudioMuter. Заметил что экземпляр объекта на сцене больше не нужен
Ошибка - нужен, случайно создавал дважды, тк как перестал быть синглтоном, надо отслеживать, что бы не было дубликатов объектов

#### 7.01.24
Добавил в интерефейсы метод при запуске менеджера - что бы отслеживать и запускать их по необходимости - продолжаю отказываться от методов Star и Awake 
Осталось придумать как убрать синглтон, что бы при этом все равно был только один экземпляр менеджера на сцене и не поялвлялось дубликатов. 
Отказаться от всех глобальных сосотояний и перейти на сервис локатор. 
Надо переписать в каждом скрипте методы и переменные ссылающиеся на Instance
[[InitializationManager]]

#### 10.01.24
Дописываем заметку про Инициализацию и внутренние зависимости 

#### 21.01.24
Нашел ошибку перехода между сценой меню и сценой игры ( вызывал метод старт у еще не активированных менеджеров)
На данный момент есть ошибка при обратном действии (при переходе из игры в меню и при перезагрузке игры, отказывает метод GameInput)
Поправил название сцен в методах загрузки сценыв MainMenuManager (перевел с билд индекс на просто имя сцены)
Добавил в интерфейс аудио, возможность инициализации плеера
В ServiceLocator добавил отслеживания уже записаных менеджеров и удаление объектов этих менеджеров при наличии их в записи
Продолжаю писать заметку про Логику и архитектуру своего проекта, перенесу данные из заметки [[InitializationManager]] в [[МОЯ АРХИТЕКТУРА И ЗАВИСИМОСТИ]]

Сделал GUIManager - не зависимым от GameManager.Instance - теперь загрузка имени и обращения к playerData - происходит в вызове скрипта в методе StartManager при прямом обращений к скрипту SaveManager и загрузки playerData

#### 29.01.24
Продолжаем делать рефакторинг нашего кода
Изменил методы в скрипте *SaveLoadMenu* - что бы теперь данный скрипт обращался к интерфейсу *SaveLoadManager*, а не к его instance
Так же начинаю изменять методы старта наших скриптов. Теперь *SaveLoadMenu* - стартует из *MenuManager*, а он в свою очередь из *InitializationManager*
- [ ] Сделать загрузку последнего сохранения в скрипте инициализации
- [ ] Сделать сохранение данных загрузке в отдельном скрипте
- [ ] Сохранять данные о выбранной загрузке, что бы после обращаться к ним *Вызвать через событие* 
- [ ] Спросить у нейронки *расскажи как написать класс GameManager, который будет без использования Синглтона, но будет существовать только в одном экземпляре на сцене, при запуске мы записываем его Интерфейс в Серивис Локтор и обращаемся через паттерн сервис локатор к этому скрипту из других частей нашего проекта*

#### 05.02.25
Обновил заметки с Obsydian в Гите
Заменил СинглТОн GameInput - на ServiceLocator в скриптах где он встречается
Переписал скрипт PauseMenu, теперь он загружается из префаба и разбит на 2 скрипта
Расфасовал по папкам скрипты

#### 06.02.25
Разберемся с [[DI+Unity ZENJECT]] - ЧТО то понял, но больше НИЧЕГо не понял и не получилось НИФИГА
Решил дальше продолжать РЕФАКТОРИТЬ все что уже написано. Удаляю огромное количество СИнглТОнов и статических классов, меняя все это на DI+ServiceLocator/ 
Как понял с форумов и прочих новостных мест, статей и видео про ZENJECT - мой метод тоже не самый лучший, и надо будет в любом случае писать через ZENJECT, но на данный момент попытаюсь хотя бы разобраться с тем что имею 
УДАЛИЛ INSTANCE из GameManager - и СНЕС ВЕСЬ КОД - надо все исправлять. 
Оставлял GameManager - как способ хранения PlayerData, но тк он нафиг не сдался - решил написать другой класс, который будет отвечать за хранение АВТОРИЗОВАННЫХ (ЗАГРУЖЕННЫХ) данных - назвал его *AUTARIZATIONMANAGER*
Суть класса будет в загрузке и передачи загруженных данных другим, необходимым классам. 
По этапу - инициализируется класс, после saveManager - и загружает последнее сохранение.
Необходимо сделать следующее, 
- [x] сделать обращение к нему из Player
- [x] сделать обращение к нему из  MainMenuManager
- [ ] переписать PlayerData 
- [x] Дописать метод событие отвечающее за загрузку (что бы маркер последнего сохраения падал на последнюю выбранную загрузку, а не запись в реестре)
- [ ] И все что будет далее по списку 

#### 05.03.25
Поправил *AutarizationManager* в инициализации
Изменил методы вызова окон Инвентаря, ачивок и статов - теперь вызываем их напрямую из файла, без указания на всякие инстансы от других классов, так как в классе GUIManager - присутствует экземпляр ResourceLoadManager - и мы запускаем прямо через него 
Составляю схему отношении классов менеджеров между друг другом, что бы все структуризировать. 
Указал что *GUIMANAGER и MainMenuManager* получают данный от *AutarizationManager* 
Поправил указание имени в *SaveLoadMenu* в методе LoadGame, поправил обновление данных об имени в *MainMenu* и теперь все снова заработало
==ДОБАВИТЬ СТЕЙТМАШИН ДЛЯ ОТСЛЕЖИВАНИЯ СОСТ ВСЕИ ИГРЫ==
~~Продолжаем попровлять загрузку в начале игры (ошибка смены данных пользователя при выборе другой загрузки )~~

#### 06.03.25
GUIManager - настроил что поля с окнами только для чтения
Добавил метод в интерфейс IMapManager для загрузки карты
DisableManager MenuManager в InitializationManager
В Teleport - отказ от Find в пользу ServiceLocator
SaveLoadMenu - поменял очередность вызова слушателя кнопок,а то срабатывало только после второго нажатия
Убрал СинглТОн из *GUIManager*
Подредачил создание пользователя и сохранении PlayerData в AutarizationManager
==<span style="background:#b1ffff">Решил оставить Player - СИНГЛТОНОМ</span>
СинглТонами остались Player и initializationManager

#### 13.03.25
Поправил в MainMenuManager условие для загрузки

#### 15.03.25
Решил добавить отдельный менеджер ,который будет отвечать за уведомление об ошибках, назвал его [[NotificationManager]] - запускается сразу после [[InitializationManager]] и загружает в себя уведомительные (системные)  окна из ресурсов проекта 
Данный менеджер необходим, что бы выводить ошибки не в консоль, а напрямую в окна игры (что бы пользователь мог видеть что случилось)  - Часть данного функционала была в *GUIManager*, но его загрузка осуществляется уже в сцене *игры*, и в сцене с *меню* он никак не задействован. Поэтому лучше вынести данный функционал в отдельный класс-менеджер. 
Пока что только перенес функционал с *GUIManager* в *NotificationManger*
Перенес функционал отображения окон с ошибками в NotificationManager осталось отредактировать *GUIManager* -что бы избавиться в нем от ненужного функционала.
Создал префаб менеджера 

#### 19.03.25
Необходимо внедрить [[StateMachine]]
#### 21.03.25
Task:
- [x] Пришла идея о новой фиче и функционале - *NotificationManager* , добавить к *WarningWindow* - звуковое сопровождение об ошибке и сделать звуковое  сопровождение как уведомление в случае если функционал заблочен для персонажа (игрока, пользователя) - вызывать не окно, а звук ошибки. 
- [ ] Поправить *GUIManager* и сделать отдельный класс, который будет от него зависеть, но так же отвечать за функционал вызова окон (Или вовсе, перенести все стартовые окна в *StartScreenManager*) 
- [ ] В схеме зависимостей дошел до этапа описания работы *GUIManager* - необходимо описать его и далее

#### 24.03.25
Планирую закончить описание заметки и составление схемы зависимостей скриптов и их работы

Добавил Метод  в *NotificationManager* для срабатывания звука при невозможности использования, своего рода звуковое уведомелние без необходимости вызова окна с ошибкой
На окно с ошибкой, поставлю отдельный звук для загрузки и вызова при появлении
Звуки кликов, вызова менюшек и прочие будут загружаться и вызываться из *AudioManager*
Добавил в *ResourceLoadManager* методы, которые могут загружать аудоклипы из папки Resources
Добавил немного аудио ресурсов
Убрал из GUIManager - функционал отвечающий за отображения окна уведомления об ошибке (теперь этот функционал только у NotificationManager)
Дописал в Архитектуре работу *GUIManager* 
Получил правки по UI/UX дизайну, пора бы его переделать 

#### 25.03.25
Нашел способ как можно сделать [[Blur для элементов UI]] Добавил его на основную картинку, не получилось размыть отдельно Panel (Display), иначе перекрывает всю картинку сзади и не становится полупрозрачной (пришлось вешать на обычную и придумывать как управлять через код при открытии разных элементов) 
Стандартный Amount = 0.68, для размытия можно = 4,8
Сделал это в *MainMenuManager* - добавил скрипт BlurOff и BlurOn от Background - Обращения к компонентам, и подключил при управлении нажатия на кнопки (вызова и закрытия меню соответственно)

#### 26.03.25
Добавим функционал, отвечающий за подсветку, при наведении курсора [[Подсветка при наведении курсора]]
Добавил скрипт, отвечающий за подсветку кнопок при наведении курсора мыши на них, и снятие подсветки при нажатии
Написал скрипт, отвечающий за проигрывания звуков нажатия на кнопку [[Звук нажатия на кнопку]] (прикрепил его к MainMenuManager для удобного вызова в меню, по поводу того как делать в сцене игры еще не решал, но тоже куда то надо будет его привесить и сделать скрипт ответственный за нажатие кнопок, ну или на саму кнопку вешать)
Добавил в аудиоМенеджер возможность получать из него данные о уровне звука, для управления громкостью нажатия кнопки через один менеджер.
Написал пользовательские ошибки и try/catch для них, что бы срабатывал только звук уведомления что, что то не так, а не оба звука [[Custom Exceptions]]
Переделываю *ГЛАВНОЕ МЕНЮ* - поскольку надо будет добавлять СЕРВЕРНУЮ логику и необходимо понятие авторизации, пользователя. Сделал префаб для *АВТОРИЗАЦИИ*
Визуально переделал *NewGameMenu* - теперь необходимо сделать в нем логику действий
Составил схему для переработки *ГЛАВНОГО МЕНЮ*
![[Pasted image 20250326194122.png]]

#### 27.03.25
Поправил функционал главного меню, изменил расположение кнопок. 
Изменение логики загрузки кнопок (но надо будет еще поделать логику для запуска, возможно сделать [[BootsTrapScene]])
Изменил окно опций, загрузки, закрытия игры (необходимо будет добавить логику в функционал)
Пытался настроить звук закрытия в родительском классе и дочерних с окнами - но что то не хочет оно срабатывать, надо будет закинуть в отдельный скрипт или написать отдельный блок для такого

#### 29.03.25
Добавил интерфес IManager - в котором записал метод характерный для всех классов менеджеров StartManager()
Убрал лишние using в скриптах

#### 30.03.25
Переписал стандартные методы возвращающие и устанавливающие закрытие члены класса На свойства класса в *Player*
Дописал свойства для *ActieWeapon* (надо будет везде по ходу проекта поменть на данную фичу)
Изменил в *AudioManager* - интерфес (добавил *PlayAudio()* и *ResourceLoadManager* для загрузки аудио клипов из папки ресурсов) 
Проигрывание звука клика можно теперь делать с помощью обращения к менеджеру который не закрывается и единственный в своем роде
но надо исправить ошибку когда срабатывает звук игрока, а не кнопки при закрытие окна меню gui 
добавил в *StartScreenManager* - в методе кнопки - звук от аудио

Создал *BootsTrapScene* для управления загрузками данных и менеджеров, управления меню загрузкой и StateMachine
Пора делать рефакторинг в сторону [[StateMachine]] для управления состояниями проекта
Добавил интерес состояние, менеджер для отслеживания и закинул все это в [[BootsTrapManager]]

#### 31.03.25
Решил добавить компонет *ButtonClick* к *Window* и *StartScreenManager* - что бы не повторять логику клика через *AudioManager*
Но думаю стоит добавить этот компонент к *AudioManager* -и вызвать его из него
Заменил *ButtonClickAudio* в *MainMenuManager* на обращение к нему же через интерфейс *IAudioManager* - теперь логика звука находится в *AudioManager*
<span style="background:#fff88f">ТЕПЕРЬ ЛОГИКУ КЛИКА МОЖНО ВЫЗЫВАТЬ ИЗ *AUDIOMANAGER* в любом участке кода</span>
Не получилось поменять *SetVolume()* в *VolumController* на свойство *AudioVolume*, пришлось оставить как было через стандартный вызов через функцию обращение
Надо проработать [[BootsTrapScene]] и [[BootsTrapManager]] - что бы загружать файлы проекта в режиме асинхронности 
Сделал корутину для регенерации здоровья и манны [[Health and Mana Regeneration Coroutine]] и добавил её к *Player* - почему то слетел отзыв методы отвечающего за отключение анимации в *MagicAttack* - решил проблему указав заново