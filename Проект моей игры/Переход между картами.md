Реализовать переход персонажа с загрузкой между разных карт 
Загрузка карт осуществляется через GUI_Manager 
Переход сделать можно двумя способами

1. Телепорт через панели на полу
2. Двери в стенах 

Надо сделать что бы персонаж переносился на новую карту, с сохранением всех  своих данных, инвентаря и состояния здоровья. А не создавался и загружался заново 

Для реализации перехода персонажа между разными картами в Unity с сохранением всех его данных, включая инвентарь и состояние здоровья, можно использовать несколько шагов:

### Шаги для реализации перехода персонажа между картами

1. **Создание менеджера загрузки (GUI_Manager)**.
2. **Создание объектов телепортации и дверей**.
3. **Сохранение данных персонажа**.
4. **Загрузка данных персонажа на новой карте**.

### 1. Создание менеджера загрузки (GUI_Manager)

Создайте скрипт `GUI_Manager`, который будет управлять переходами между картами. Он будет обрабатывать события, связанные с телепортацией и взаимодействием с дверями.
```
using UnityEngine;
using UnityEngine.SceneManagement;

public class GUI_Manager : MonoBehaviour
{
    public void LoadScene(string sceneName)
    {
        // Сохраняем данные персонажа перед загрузкой новой сцены
        SavePlayerData();

        // Загружаем новую сцену
        SceneManager.LoadScene(sceneName);
    }

    private void SavePlayerData()
    {
        // Здесь вы должны сохранить информацию о состоянии персонажа
        // Например, здоровье и инвентарь
        PlayerData.Save();
    }
}
```
### 2. Создание объектов телепортации и дверей

#### Телепорт

Создайте объект телепорта, который будет триггером для перехода. Вы можете использовать `BoxCollider` в качестве триггера.
```
using UnityEngine;

public class Teleport : MonoBehaviour
{
    public string sceneToLoad; // Имя сцены для загрузки
    public Vector3 teleportPosition; // Позиция, куда персонаж будет перемещен

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            GUI_Manager guiManager = FindObjectOfType<GUI_Manager>();
            guiManager.LoadScene(sceneToLoad);
        }
    }
}
```
#### Двери

Создайте объект двери с аналогичным методом.
```
using UnityEngine;

public class Door : MonoBehaviour
{
    public string sceneToLoad; // Имя сцены для загрузки
    public Vector3 doorPosition; // Позиция, куда персонаж будет перемещен

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            GUI_Manager guiManager = FindObjectOfType<GUI_Manager>();
            guiManager.LoadScene(sceneToLoad);
        }
    }
}
```
### 3. Сохранение данных персонажа

Создайте класс `PlayerData`, который будет хранить все необходимые данные о персонаже, такие как здоровье и инвентарь. Этот класс может сохранять данные в статические переменные или использовать другие методы хранения.

```
using UnityEngine;

public static class PlayerData
{
    public static int health;
    public static Inventory inventory; // Ссылка на инвентарь персонажа

    public static void Save()
    {
        // Например, сохраним здоровье
        health = FindObjectOfType<Player>().currentHealth;
        
        // Для сохранения инвентаря вызовите метод сохранения вашего инвентаря
        inventory = FindObjectOfType<Inventory>();
        // Если у вас есть сериализация инвентаря, можете ее использовать здесь
    }

    public static void Load()
    {
        // Здесь вы можете восстанавливать здоровье и инвентарь
        FindObjectOfType<Player>().currentHealth = health;
        // Восстановите инвентарь, аналогично
    }
}
```
### 4. Загрузка данных персонажа на новой карте

При загрузке новой сцены вы можете восстановить данные персонажа.

#### Вызов загрузки в персонаже

В методе `Start()` или `Awake()` вашего персонажа добавьте вызов загрузки данных:
```
using UnityEngine;

public class Player : MonoBehaviour
{
    public int currentHealth;

    private void Start()
    {
        PlayerData.Load(); // Загружаем данные при старте
        currentHealth = PlayerData.health; // Восстанавливаем здоровье
        // Загружаем инвентарь здесь
    }
}
```
### Заключение

Теперь ваш персонаж будет корректно переходить между картины с сохранением всех важный данных, таких как здоровье и инвентарь. Телепорты и двери будут запускать загрузку необходимых сцен через `GUI_Manager`, который сохраняет состояние персонажа перед сменой карты.

## При наличии всех карт-префабов в Hierarchy

Если у вас уже есть метод для загрузки карты, который не использует переключения между сценами, а управляет несколькими картами в одной сцене, тогда вам просто нужно убедиться, что при переключении между картами вы сохраняете и восстанавливаете состояние персонажа, как здоровье и инвентарь.

### Реализация перехода между картами с учетом вашего метода

1. **Создание карт в виде объектов**: Убедитесь, что каждый объект карты (например, `map`) находится под управлением вашего метода `LoadMap`. Эти карты могут быть разными объектами в иерархии Unity, расположенными в одном родительском объекте.
    
2. **Сохранение и восстановление состояния персонажа**: Его состояние нужно будет сохранять при переходе с одной карты на другую.
    
3. **Изменение метода `LoadMap`**: Включите в метод сохранение и восстановление данных персонажа.
    

### Пример реализации

Ваш метод для загрузки карты может выглядеть следующим образом:
```
public void LoadMap(int index)
{
    if (index < 0 || index >= maps.Count)
        return;

    // Сохранить состояние текущего персонажа (например, здоровье и инвентарь)
    SavePlayerState();

    // Скрыть все карты
    foreach (var map in maps)
    {
        map.gameObject.SetActive(false);
    }

    // Отображаем выбранную карту
    maps[index].gameObject.SetActive(true);
    currentMapIndex = index;

    // Восстановить состояние персонажа на новой карте
    RestorePlayerState();
}
```

### Реализация методов сохранения и восстановления состояния

#### Метод для сохранения состояния персонажа
```

private void SavePlayerState()
{
    Player player = FindObjectOfType<Player>();

    // Сохраняем здоровье
    PlayerData.health = player.currentHealth; // Например, используйте свой класс PlayerData
    PlayerData.inventory = player.inventory; // Предполагается, что Inventory доступен
}

```

#### Метод для восстановления состояния персонажа
```
private void RestorePlayerState()
{
    Player player = FindObjectOfType<Player>();

    // Восстанавливаем здоровье
    player.currentHealth = PlayerData.health;

    // Здесь также можете восстановить инвентарь, если у вас есть такая логика
    if (PlayerData.inventory != null)
    {
        player.inventory = PlayerData.inventory; // Восстановите инвентарь
        // Например, вызовите метод обновления UI инвентаря, если это необходимо
        player.inventory.UpdateInventoryUI(); // Настройте этот метод в вашем классе Inventory
    }
}
```
### Учитывайте переходы с помощью объекта телепортации и дверей

Если у вас есть телепорты или двери на каждой карте, которые могут запускать переходы, убедитесь, что они вызывают `LoadMap()` с правильным индексом соответствующей карты.

Пример кода для телепортации:
```
using UnityEngine;

public class Teleport : MonoBehaviour
{
    public int mapIndex; // Индекс карты для перехода

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            GUI_Manager guiManager = FindObjectOfType<GUI_Manager>();
            guiManager.LoadMap(mapIndex); // Переход к соответствующей карте
        }
    }
}
```
### Заключение

Теперь у вас есть метод для загрузки карты, который сохраняет и восстанавливает состояние персонажа при переключении между картами внутри одной сцены. Этот подход позволяет динамично управлять игровым процессом, избегая переключений между сценами, сохраняя при этом важные данные персонажа.

## Так как наши карты ПРЕФАБЫ и загружаются не из сцены
То использовать надо следующие шаги

Если ваши карты представлены как префабы в проекте и не находятся в иерархии, вам нужно динамически загружать и создавать префабы карт на месте, когда вызывается метод `LoadMap`. Это будет включать в себя создание нового экземпляра префаба для новой карты и удаление предыдущего экземпляра.

### Пример реализации динамической загрузки карт

Ниже представлен обновленный метод `LoadMap`, который будет загружать новую карту, удаляя старую карту из иерархии.

#### 1. Создание списка префабов карт

Предположим, у вас есть список префабов карт в вашем `MapManager`.
```
using UnityEngine;

public class MapManager : MonoBehaviour
{
    public GameObject[] maps; // Массив префабов карт
    private GameObject currentMap; // Текущая карта

    public void LoadMap(int index)
    {
        if (index < 0 || index >= maps.Length)
            return;

        // Удаление текущей карты, если она существует
        if (currentMap != null)
        {
            Destroy(currentMap); // Удаляем старую карту
        }

        // Загружаем новую карту
        currentMap = Instantiate(maps[index]); // Создаём новый экземпляр карты
        currentMap.transform.position = Vector3.zero; // Устанавливаем нужную позицию, если необходимо
    }
}
```
#### 2. Настройка префабов карт

- Убедитесь, что все ваши карты сохранены как префабы в проекте.
- Присвойте все префабы карт в инспекторе вашему `MapManager` в массив `maps`.

#### 3. Реализация переключения через триггер

Теперь ваш скрипт триггера для телепортации или двери будет выглядеть следующим образом:
```
using UnityEngine;

public class Teleport : MonoBehaviour
{
    public int mapIndex; // Индекс карты для загрузки

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            MapManager guiManager = MapManager.Instance; // Доступ к экземпляру MapManager
            guiManager.LoadMap(mapIndex); // Загружаем выбранную карту
        }
    }
}
```

### Обновлённые методы для работы с массивами
```
// Метод для переключения на следующую карту
public void SwitchToNextMap()
{
    currentMapIndex = (currentMapIndex + 1) % maps.Length; // Вычисляем индекс следующей карты
    LoadMap(currentMapIndex); // Загружаем следующую карту
}

// Метод для переключения на предыдущую карту
public void SwitchToPreviousMap()
{
    currentMapIndex = (currentMapIndex - 1 + maps.Length) % maps.Length; // Вычисляем индекс предыдущей карты
    LoadMap(currentMapIndex); // Загружаем предыдущую карту
}
```

### Объяснение изменений

1. **Использование `maps.Length`**:
    
    - Вместо `maps.Count`, который используется в списках, для массивов используется `maps.Length` для получения размера массива.
2. **Изменения индексов**:
    
    - В методах сохраняется прежняя логика для вычисления индексов. `currentMapIndex` увеличивается или уменьшается, и затем применяется оператор `%` для обеспечения цикличности. Это значит, что если текущий индекс выходит за пределы массива, он вернётся к началу (в случае следующей карты) или к концу (в случае предыдущей карты).


### Заключение

Теперь, при входе игрока в триггер, текущая карта будет удалена, и на её месте появится новая карта, соответствующая индексу, заданному в `mapIndex`. Убедитесь, что все префабы карт правильно настроены и назначены в инспекторе.

