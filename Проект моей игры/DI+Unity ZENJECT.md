-Создает внутренние легкие зависимости внутри проекта. 

### ZENJECT
-Фраймворк для среды UNITY, который используют ля внедрения зависимостей (поможет избежать синглтонов и прочей ерунды)

##### это DI Контртейнер.

### DI-это
 Зависимость - это один класс использует услуги других классов, что бы что то там решить и делать. 
 Через конструктор, подключаем другие сервисы к нашему классу 
  Существуют явные и не-яные зависимости 

Явные зависимости - видны через класс конструктора, и то что ему передается  в качестве аргументов. 

Не явные зависимости - это как раз использование синглтонов, когда внутри класса мы можем начинать неявно обращатся по ссылке через инстанс к другим классам, из за чего наш код становится СЛАБОЧИТАЕМЫМ и не понятным от чего зависит ,пока мы его целиком не проштудируем

#### DI-Zenject контейнер 
Позволяет нам видеть все зависимости между классами. Регистрировать их и делать наш код чище и яснее для понимания. 

Нам хочется, что бы машина работала на максимум - что бы можно было всем необходимым зависимостям можно было раздать их автоматически 

Скачать и установить его можно по ссылке с гитхаба
github.com/svermeulen/Extenject/releases и распаковываем в наш проект в Unity

После импорта Zenject в проект игры, мы сможем создавать объекты вида Zenject и использовать их, по примеру видео туториала [DI + UNITY ZENJECT ⚡️ Dependency injection в Unity - смотреть видео онлайн от «Схрон (эвакуация видосов с ТыТрубы)» в хорошем качестве, опубликованное 23 августа 2024 года в 13:59:07.](https://rutube.ru/video/8ee8a15f3d744254fe377587340e8647/?playlist=509380)
Я создал папку TestZenject->Resources и туда добавил Zenject->ProjectContext
После, в окне Hierarchy->Create new->Zenject->SceneContext
SceneContext - Нужен что бы Boost'апнуть все прочие ProjectContext. В самом начале он проверяет есть ли где то на сцене ProjectContext если нет, то создает его.

Работает это за счет Script Execution Order (Но с помощью него мы не решаем свои проблемы с инициализацией)
Запихиваем туда только свой Boost'апер или от Плагинов
###### Метод инициализации - Сперва SceneContext-срабатывает самым первым (он в свою очередь ищет PrejectContext (Инициализирует его зависимости, делает его DontDestroyLoad), после инициализируется сам).

Создадим папку в нашей Тестовой папку, Infrasturcture и добавим в нее следующий скрипт
```
using Zenject;

namespace Assets.TestZenject.Infrastracture
{
    public class BootstrapInstaller : MonoInstaller
    {
        //В данном классе будут регистрироваться сервисы, которые будут находится в процессе всей игры
        public override void InstallBindings()
        {
           
        }
    }
}
```
После - повесим данный скрипт на ProjectContext и добавим его в графу Mono

Далее, создадим второй объект SceneContext, уже на нашей основной сцене и попробуем переписать код так, что бы наш игрок теперь загружался из префаба в точку загрузки на сцене, а все зависимости от него приходили к объектам через на Zenject

Создадим объект, назовем его StartPosition и поместим его в точку старта нашего героя

Создадим новый класc и повесим его на наш SceneContext
```
namespace Assets.TestZenject.Infrastracture
{
    public class LocationInstaller : MonoInstaller
    {
        //В данном классе будут регистрироваться сервисы, которые будут жить только на определенной сцене

        public Transform StartPoint;
        public GameObject HeroPrefab;

        public override void InstallBindings()
        {
            Player player = Container
                .InstantiatePrefabForComponent<Player>(HeroPrefab, StartPoint.position, Quaternion.identity, null);

            Container
        }
    }
}
```